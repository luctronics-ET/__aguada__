<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hist√≥rico - AGUADA Dashboard</title>
    <link rel="stylesheet" href="assets/style.css" />
    <link rel="stylesheet" href="assets/loading-states.css" />
  </head>
  <body>
    <div class="admin-header">
      <div class="admin-header-top">
        <h1>üìä Hist√≥rico de Leituras - AGUADA</h1>
        <div class="status-indicator">
          <div class="status-dot"></div>
          <span>‚óè Online</span>
        </div>
      </div>
      <nav class="admin-nav">
        <a href="index.html">Dashboard</a>
        <a href="mapa.html">Mapa</a>
        <a href="painel.html">Painel Visual</a>
        <a href="dados.html">Dados</a>
        <a href="consumo.html">Consumo</a>
        <a href="abastecimento.html">Abastecimento</a>
        <a href="manutencao.html">Manuten√ß√£o</a>
        <a href="history.html" class="active">Hist√≥rico</a>
        <a href="alerts.html">Alertas</a>
        <a href="config.html">Configura√ß√µes</a>
        <a href="system.html">Sistema</a>
        <a href="documentacao.html">Docs</a>
      </nav>
    </div>

    <div class="main-container">
      <div class="card" style="margin-bottom: 30px">
        <div class="card-header">
          <span>Filtros e Op√ß√µes</span>
        </div>
        <div class="card-body">
          <form
            id="filterForm"
            style="
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
            "
          >
            <div>
              <label>Sensor</label>
              <select id="sensorFilter">
                <option value="">Todos</option>
                <option value="RCON">RCON</option>
                <option value="RCAV">RCAV</option>
                <option value="RB03">RB03</option>
                <option value="IE01">IE01</option>
                <option value="IE02">IE02</option>
              </select>
            </div>
            <div>
              <label>Tipo de Dado</label>
              <select id="typeFilter">
                <option value="distance_cm">Dist√¢ncia</option>
                <option value="valve_in">V√°lvula Entrada</option>
                <option value="valve_out">V√°lvula Sa√≠da</option>
                <option value="sound_in">Fluxo de √Ågua</option>
              </select>
            </div>
            <div>
              <label>Per√≠odo</label>
              <select id="periodFilter">
                <option value="1d">√öltimas 24h</option>
                <option value="7d">√öltimos 7 dias</option>
                <option value="30d">√öltimos 30 dias</option>
                <option value="all">Todos</option>
              </select>
            </div>
            <div style="display: flex; gap: 10px; align-items: flex-end">
              <button
                type="button"
                class="btn-primary"
                onclick="applyFilters()"
              >
                Aplicar
              </button>
              <button
                type="button"
                class="btn-secondary"
                onclick="exportData()"
                style="background: #6b7280; color: white"
              >
                Exportar
              </button>
            </div>
          </form>
        </div>
      </div>

      <div class="dashboard-grid">
        <div class="card grid-full">
          <div class="card-header">
            <span>Gr√°fico de Tend√™ncia</span>
          </div>
          <div class="card-body" style="text-align: center">
            <canvas
              id="trendChart"
              style="max-width: 100%; height: 300px"
            ></canvas>
            <p style="color: #999; margin-top: 10px; font-size: 12px">
              üìå Gr√°fico em tempo real - atualiza a cada 30 segundos
            </p>
          </div>
        </div>
      </div>

      <div class="card" style="margin-bottom: 30px">
        <div class="card-header">
          <span>Tabela de Leituras</span>
          <span id="readingCount" style="font-size: 12px">0 registros</span>
        </div>
        <div class="card-body">
          <table id="readingsTable">
            <thead>
              <tr>
                <th>Timestamp</th>
                <th>Sensor</th>
                <th>Tipo</th>
                <th>Valor</th>
                <th>Unidade</th>
                <th>Bateria</th>
                <th>RSSI</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="7" style="text-align: center; color: #999">
                  ‚è≥ Carregando dados...
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="stats-footer">
        <div class="stat">
          <div class="stat-value" id="maxValue">0</div>
          <div class="stat-label">M√°ximo</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="minValue">0</div>
          <div class="stat-label">M√≠nimo</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="avgValue">0</div>
          <div class="stat-label">M√©dia</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stdValue">0</div>
          <div class="stat-label">Desvio Padr√£o</div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="assets/layout.js"></script>
    <script src="assets/api-service.js"></script>
    <script src="assets/ui-utils.js"></script>
    <script src="assets/app.js"></script>
    <script>
      // Load history data
      let historyData = {};
      let filteredData = [];

      async function initHistory() {
          // Fetch real data from API
          try {
              if (!window.apiService) {
                  console.warn('[History] API Service n√£o dispon√≠vel');
                  // Aguardar um pouco e tentar novamente
                  setTimeout(initHistory, 1000);
                  return;
              }

              // Buscar lista de sensores primeiro
              let sensors = {};
              try {
                  const sensorsResponse = await window.apiService.getSensorsStatus();
                  if (Array.isArray(sensorsResponse)) {
                      sensorsResponse.forEach(s => {
                          const elementoId = s.elemento_id || s.sensor_id;
                          sensors[elementoId] = {
                              sensor_id: s.sensor_id,
                              elemento_id: elementoId
                          };
                      });
                  }
              } catch (error) {
                  console.warn('[History] Erro ao buscar sensores, usando lista padr√£o:', error);
                  // Fallback para lista padr√£o
                  sensors = {
                      'RCON': { sensor_id: 'RCON_US01', elemento_id: 'RCON' },
                      'RCAV': { sensor_id: 'RCAV_US01', elemento_id: 'RCAV' },
                      'RB03': { sensor_id: 'RB03_US01', elemento_id: 'RB03' },
                      'IE01': { sensor_id: 'IE01_US01', elemento_id: 'IE01' },
                      'IE02': { sensor_id: 'IE02_US01', elemento_id: 'IE02' }
                  };
              }

              // Buscar hist√≥rico de todos os sensores
              const promises = Object.entries(sensors).map(async ([elementoId, sensor]) => {
                  try {
                      const history = await window.apiService.getReadingHistory(
                          sensor.sensor_id || elementoId,
                          7,
                          'distance_cm'
                      );
                      return [elementoId, (history || []).map(h => ({
                          timestamp: h.datetime || h.timestamp,
                          datetime: h.datetime || h.timestamp,
                          valor: h.valor,
                          distance_cm: parseFloat(h.valor || 0),
                          battery: h.battery || h.meta?.battery_mv || 0,
                          rssi: h.rssi || h.meta?.rssi_dbm || 0,
                          meta: h.meta || {}
                      }))];
                  } catch (error) {
                      console.error(`[History] Erro ao buscar hist√≥rico de ${elementoId}:`, error);
                      return [elementoId, []];
                  }
              });

              const results = await Promise.all(promises);
              results.forEach(([elementoId, data]) => {
                  historyData[elementoId] = data;
              });
          } catch (error) {
              console.error('[History] Erro ao inicializar:', error);
          }

          loadReadings();
          updateStats();
          renderChart();
      }

      function loadReadings() {
          const tbody = document.querySelector('#readingsTable tbody');
          tbody.innerHTML = '';

          let sensor = document.getElementById('sensorFilter').value;
          let type = document.getElementById('typeFilter').value;
          let period = document.getElementById('periodFilter').value;

          // Filter data
          filteredData = [];
          Object.entries(historyData).forEach(([sId, readings]) => {
              if (sensor && sId !== sensor) return;

              readings.forEach(reading => {
                  // Filtrar por per√≠odo
                  if (period === '1d') {
                      const oneDay = new Date(Date.now() - 24 * 60 * 60 * 1000);
                      const readingDate = new Date(reading.timestamp || reading.datetime || 0);
                      if (isNaN(readingDate.getTime()) || readingDate < oneDay) return;
                  } else if (period === '7d') {
                      const sevenDays = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                      const readingDate = new Date(reading.timestamp || reading.datetime || 0);
                      if (isNaN(readingDate.getTime()) || readingDate < sevenDays) return;
                  } else if (period === '30d') {
                      const thirtyDays = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                      const readingDate = new Date(reading.timestamp || reading.datetime || 0);
                      if (isNaN(readingDate.getTime()) || readingDate < thirtyDays) return;
                  }

                  filteredData.push({
                      sensor: sId,
                      timestamp: reading.timestamp || reading.datetime,
                      datetime: reading.datetime || reading.timestamp,
                      ...reading
                  });
              });
          });

          // Render rows
          if (filteredData.length === 0) {
              tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #999;">Nenhum dado encontrado</td></tr>';
          } else {
              filteredData.forEach(reading => {
                  const row = document.createElement('tr');

                  // Formatar timestamp corretamente
                  let timestampStr = '-';
                  try {
                      if (reading.timestamp) {
                          const date = new Date(reading.timestamp);
                          if (!isNaN(date.getTime())) {
                              timestampStr = typeof formatDateTime === 'function'
                                  ? formatDateTime(reading.timestamp)
                                  : date.toLocaleString('pt-BR');
                          } else {
                              timestampStr = reading.timestamp;
                          }
                      }
                  } catch (e) {
                      timestampStr = reading.timestamp || '-';
                  }

                  // Formatar valor - os dados podem vir como 'valor' ou como propriedade direta
                  let valueDisplay = '-';
                  const valor = reading.valor !== undefined ? reading.valor :
                               reading[type] !== undefined ? reading[type] :
                               reading.distance_cm !== undefined ? reading.distance_cm : null;

                  if (valor !== null && valor !== undefined) {
                      if (type === 'distance_cm') {
                          valueDisplay = (parseFloat(valor) / 100).toFixed(2) + ' m';
                      } else if (type === 'valve_in' || type === 'valve_out' || type === 'sound_in') {
                          valueDisplay = (valor === '1' || valor === 1 || valor === true) ? '‚úì Ativo' : '‚úó Inativo';
                      } else {
                          valueDisplay = String(valor);
                      }
                  }

                  // Extrair bateria e RSSI do meta se dispon√≠vel
                  let batteryDisplay = '-';
                  let rssiDisplay = '-';

                  if (reading.battery) {
                      batteryDisplay = typeof reading.battery === 'number' && reading.battery > 1000
                          ? (reading.battery / 1000).toFixed(2) + ' V'
                          : reading.battery + ' mV';
                  } else if (reading.meta && typeof reading.meta === 'object' && reading.meta.battery_mv) {
                      batteryDisplay = (parseFloat(reading.meta.battery_mv) / 1000).toFixed(2) + ' V';
                  }

                  if (reading.rssi) {
                      rssiDisplay = reading.rssi + ' dBm';
                  } else if (reading.meta && typeof reading.meta === 'object' && reading.meta.rssi_dbm) {
                      rssiDisplay = reading.meta.rssi_dbm + ' dBm';
                  }

                  row.innerHTML = `
                      <td>${timestampStr}</td>
                      <td><strong>${reading.sensor || '-'}</strong></td>
                      <td>${type === 'distance_cm' ? 'Dist√¢ncia' :
                            type === 'valve_in' ? 'V√°lvula Entrada' :
                            type === 'valve_out' ? 'V√°lvula Sa√≠da' :
                            type === 'sound_in' ? 'Fluxo' : type || '-'}</td>
                      <td>${valueDisplay}</td>
                      <td>${type === 'distance_cm' ? 'm' : type.includes('valve') || type === 'sound_in' ? 'bool' : '-'}</td>
                      <td>${batteryDisplay}</td>
                      <td>${rssiDisplay}</td>
                  `;
                  tbody.appendChild(row);
              });
          }

          document.getElementById('readingCount').textContent = filteredData.length + ' registros';
      }

      function applyFilters() {
          loadReadings();
          renderChart();
          updateStats();
      }

      function exportData() {
          if (filteredData.length === 0) {
              alert('Nenhum dado para exportar');
              return;
          }

          const csvData = filteredData.map(r => {
              // Formatar timestamp para CSV
              let timestampStr = '-';
              try {
                  const date = new Date(r.timestamp || r.datetime || 0);
                  if (!isNaN(date.getTime())) {
                      timestampStr = typeof formatDateTime === 'function'
                          ? formatDateTime(r.timestamp || r.datetime)
                          : date.toLocaleString('pt-BR');
                  }
              } catch (e) {
                  timestampStr = r.timestamp || r.datetime || '-';
              }

              return {
                  'Data/Hora': timestampStr,
                  'Sensor': r.sensor || '-',
                  'Valor': r.distance_cm || r.valve_in || r.valve_out || r.sound_in || '-',
                  'Bateria': r.battery || '',
                  'RSSI': r.rssi || ''
              };
          });

          exportToCSV(csvData, 'aguada-historico.csv');
      }

      function updateStats() {
          const type = document.getElementById('typeFilter')?.value || 'distance_cm';

          // Extrair valores num√©ricos dos dados filtrados
          const values = filteredData
              .map(d => {
                  // Tentar obter valor de diferentes formas
                  const valor = d.valor !== undefined ? parseFloat(d.valor) :
                               d.distance_cm !== undefined ? parseFloat(d.distance_cm) :
                               d[type] !== undefined ? parseFloat(d[type]) :
                               null;
                  return valor !== null && !isNaN(valor) ? (type === 'distance_cm' ? valor / 100 : valor) : null;
              })
              .filter(v => v !== null && !isNaN(v));

          if (values.length === 0) {
              document.getElementById('maxValue').textContent = '0';
              document.getElementById('minValue').textContent = '0';
              document.getElementById('avgValue').textContent = '0';
              document.getElementById('stdValue').textContent = '0';
              return;
          }

          const max = Math.max(...values);
          const min = Math.min(...values);
          const avg = values.reduce((a, b) => a + b, 0) / values.length;
          const std = Math.sqrt(values.reduce((sq, n) => sq + Math.pow(n - avg, 2), 0) / values.length);

          document.getElementById('maxValue').textContent = max.toFixed(2);
          document.getElementById('minValue').textContent = min.toFixed(2);
          document.getElementById('avgValue').textContent = avg.toFixed(2);
          document.getElementById('stdValue').textContent = std.toFixed(2);
      }

      function renderChart() {
          const canvas = document.getElementById('trendChart');
          if (!canvas) return;

          // Verificar se Chart.js est√° dispon√≠vel
          if (typeof Chart === 'undefined') {
              canvas.parentElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">üìà Chart.js n√£o carregado. Adicione: &lt;script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"&gt;&lt;/script&gt;</div>';
              return;
          }

          // Preparar dados para o gr√°fico
          const sensor = document.getElementById('sensorFilter').value;
          const type = document.getElementById('typeFilter').value;

          let chartData = [];
          let labels = [];

          if (sensor && historyData[sensor]) {
              const sensorHistory = historyData[sensor];
              chartData = sensorHistory
                  .filter(r => {
                      const date = new Date(r.timestamp || r.datetime || 0);
                      const period = document.getElementById('periodFilter').value;
                      if (period === '1d') {
                          return date > new Date(Date.now() - 24 * 60 * 60 * 1000);
                      } else if (period === '7d') {
                          return date > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                      } else if (period === '30d') {
                          return date > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                      }
                      return true;
                  })
                  .slice(-100) // Limitar a 100 pontos
                  .map(r => {
                      const date = new Date(r.timestamp || r.datetime || 0);
                      labels.push(date.toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' }));

                      if (type === 'distance_cm') {
                          return parseFloat(r.distance_cm || 0) / 100; // Converter para metros
                      }
                      return parseFloat(r[type] || 0);
                  });
          } else if (!sensor) {
              // Se nenhum sensor selecionado, mostrar m√©dia de todos
              const allData = [];
              Object.values(historyData).forEach(sensorHistory => {
                  sensorHistory.forEach(r => {
                      const date = new Date(r.timestamp || r.datetime || 0);
                      const period = document.getElementById('periodFilter').value;
                      if (period === '1d' && date <= new Date(Date.now() - 24 * 60 * 60 * 1000)) return;
                      if (period === '7d' && date <= new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)) return;
                      if (period === '30d' && date <= new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)) return;

                      allData.push({
                          timestamp: r.timestamp || r.datetime,
                          value: type === 'distance_cm' ? parseFloat(r.distance_cm || 0) / 100 : parseFloat(r[type] || 0)
                      });
                  });
              });

              // Agrupar por hora/dia e calcular m√©dia
              const grouped = {};
              allData.forEach(d => {
                  const date = new Date(d.timestamp);
                  const key = date.toLocaleDateString('pt-BR') + ' ' ' + date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                  if (!grouped[key]) {
                      grouped[key] = { sum: 0, count: 0 };
                  }
                  grouped[key].sum += d.value;
                  grouped[key].count++;
              });

              labels = Object.keys(grouped).slice(-50);
              chartData = labels.map(key => grouped[key].sum / grouped[key].count);
          }

          // Destruir gr√°fico anterior se existir
          if (window.historyChart) {
              window.historyChart.destroy();
          }

          // Criar novo gr√°fico
          const ctx = canvas.getContext('2d');
          window.historyChart = new Chart(ctx, {
              type: 'line',
              data: {
                  labels: labels,
                  datasets: [{
                      label: type === 'distance_cm' ? 'Dist√¢ncia (m)' :
                             type === 'valve_in' ? 'V√°lvula Entrada' :
                             type === 'valve_out' ? 'V√°lvula Sa√≠da' : 'Fluxo',
                      data: chartData,
                      borderColor: 'rgba(103, 126, 234, 1)',
                      backgroundColor: 'rgba(103, 126, 234, 0.1)',
                      tension: 0.4,
                      fill: true
                  }]
              },
              options: {
                  responsive: true,
                  maintainAspectRatio: true,
                  scales: {
                      y: {
                          beginAtZero: true
                      }
                  },
                  plugins: {
                      legend: {
                          display: true,
                          position: 'top'
                      }
                  }
              }
          });
      }

      // Initialize
      initHistory();
    </script>
  </body>
</html>
